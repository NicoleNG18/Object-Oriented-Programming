# \<fstream>
Библиотеката `<fstream>` ни дава достъп до 3 нови типа.
- `ifstream` - Input File Stream - Четене от файлове
- `ofstream` - Output File Stream - Писане във файлове
- `fstream` - File Stream - Комбинация от `ifstream` и `ofstream` за четене и писане

Ще се занимаваме предимно с `ifstream` и `ofstream`.

# Текстови файлове 
## Писане към файл
За да пишем към файл, трябва да създадем обект от тип `ofstream`. Това става по следния начин:
```cpp
std::ofstream outFile("file.txt");
```
В кавичките слагаме път към файла. Написан по този начин, това е релативен път от `.exe`-то на програмата. Можем да напишем и абсолютен път, като на Windows това изглежда по следния начин: `"C:\\Users\\Kiril\\Desktop\\file.txt"`. 

*Важно 1: Когато пишем път към файл, внимаваме правилно да escape-ваме символа `\`, като пишем `\\`* (Тези видове пътища са само валидни за `Windows`, `Linux` и `MacOS` използват `/`, което няма нужда да се `escape`-не)

*Важно 2: Ако файлът не съществува, ще се създаде нов с такова име*

---

За да запишем данни през отворения поток, използваме обекта `outFile` както бихме ползвали потока `cout` - с `<<`
```cpp
outFile << "Hello, world! " << 123;
```

Сега като отворим файла `file.txt`, вътре ще има текста `"Hello, world! 123"`.

---

Ако пуснем същата програма отново, ще забележим, че съдържанието на файла не е променено. Ако променим низа, който записваме, на нещо друго, например:
```cpp
outFile << "Amazing day!";
```
ще забележим, че сега съдържанието на файла е `"Amazing day!"`.

Причината за това е че всеки път щом отворим файл и записваме данни в него, оригиналното съдържание се изтрива. За да предотвратим това поведение, трябва да използваме специалния "флаг" ```std::ios::app```. Този флаг се поставя след името на файла при инициализиране на файловия поток.

```cpp
std::ofstream outFile("file.txt", std::ios::app);
```
Сега потокът е отворен в режим на добавяне (`app` - append). Всеки текст, който добавяме, ще се добавя в края на файла, без да изтрива оригиналното съдържание. Сега като пуснем програмата 3 пъти, съдържанието от празен файл, ще бъде `"Amazing day!Amazing day!Amazing day!"`

Има още няколко флагове, но ще научим повече за тях малко по-късно.

## Четене от файл
Аналогично на писането към файл, за да четем от файл, трябва да създадем обект, този път от тип `ifstream`. Това става по следния начин:
```cpp
std::ifstream inFile("file.txt");
```
*Важно: Ако файлът не съществува или не може да се отвори, потокът няма да бъде валиден.*

---

За да прочетем данни от файла, използваме обекта `inFile` както бихме ползвали потока `cin` - с `>>`:

```cpp
int number;
inFile >> number;
std::cout << number << std::endl;
```
Това ще прочете първото число от файла (до първия интервал, табулация или нов ред)
```cpp
char buffer[256];
inFile >> buffer;
std::cout << text << std::endl;
```
Това ще прочете първата дума от файла (до първия интервал, табулация или нов ред).

---

Ако искаме да прочетем целия файл ред по ред, използваме метода `.getline`, който приема указател към низ (типично буфер), и максимален размер (типично размерът на този буфер) 

Освен това, `.getline` се превръща в булева стойност, за това можем да го използваме като условие:
```cpp
char buffer[1024];
while (inFile.getline(buffer, 1024))
{
    std::cout << buffer << std::endl;
}
```

## Записване и четене на указатели от файл
Както знаем указателите съдържат просто адрес към паметта на компютъра. Този адрес може да съдържа `int`, `char`, масив и дори друг указател. За да запишем един указател във файл, ние трябва първо да дереференцираме неговата стойност и чак тогава да запишем неговото съдржание. Защо това е така?  

Ако се опитаме да изведем един указател на конзолата със `std::cout << ptr`, то на екрана ще се визуализира адресът към който сочи `ptr`. Ако просто запишем адреса към който сочи указателят в един файл и след няколко дена отоврим същия файл и прочетем просто адреса, е силно вероятно този адрес да се използва от някой друг процес и вече да не съдържа същата информация по време на запис във файла.

Точно заради това при записване на информация във файл, ние първо трябва да дереференцираме указателят, докато той не ни върне някаква стойнсот която да запишем.  
Това важи и при масивите. В крайна сметка те са просто указател към първия елемент на масива. Точно поради тази причина ние трябва ръчно да запишем всеки елемент от масива във файла за да може при следващо отваряне за четене, да възстановим съдържанието на записания масив.  
Това важи и до променливи/масиви които съдържат в себе си някаква динамична памет(защото тя е просто указател сочещ към нея).

Когато четем от един текстов файл, за нас няма значение как е записана информацията. Единствено ни интересува какво се записано във файла, в какъв формат и как се очаква да се прочете.

# Видове файлове в С++
Всеки файл представлява поредица от байтове. До тук видяхме как боравим с *текстови* файлове (напр. `.txt`, `.cpp`, `.html`).

По подразбиране, потоците, които създаваме, работят в режим на работа с *текстови* файлове. Това означава, че всеки байт се интерпретира като символ от ASCII таблицата.

Освен режим на работа с *текстови* файлове, съществува и режим на работа с *двоични* файлове. Такива файлове са всички, които не могат да бъдат прочетени от човек (напр. `.exe`, `.dll`, `.docx`, `.png`)

И в двата случая можем да си представим файлът като масив от char-ове. 
- При текстовия файл, всеки char е символ от ASCII таблицата
- При двоичния файл, всеки char съответства на всеки **байт** от файла

# Двоични файлове
## Писане към файл
Двоичният (бинарен) режим записва данни в двоичен формат, а не в текстов. Това е по-ефективно за структурирани данни като числа и обекти.

За да пишем към файл в двоичен режим, трябва да създадем обект от тип `ofstream` и да зададем флага `std::ios::binary`. Това става по следния начин:
```cpp
std::ofstream outFile("file.bin", std::ios::binary);
```
---

За да запишем данни в бинарен файл, използваме метода `.write`. Той очаква указател към данните и броя байтове, които да запише:
```cpp
int number = 12345;
outFile.write(reinterpret_cast<char*>(&number), sizeof(number));
```

Тук:
- `reinterpret_cast<char*>` преобразува указателя към типа `char*`, тъй като `.write()` работи с байтове.
- `sizeof(number)` дава броя байтове, които трябва да се запишат.

---

Можем и да записваме обекти от структури в двоични файлове. Това е за предпочитане пред типичните текстови файлове, защото при тях трябва да преобразуваме данните от оригиналния им вид до текст, и после обратно. При двоичните файлове просто записваме данните като байтове и после ги четем, като преобразуваме байтовете в обект.

```cpp
struct Data
{
    int number;
    double precision;
    char letter;
};
```

```cpp
Data data {5, 0.03, 'G'};

outFile.write(reinterpret_cast<char*>(&data), sizeof(data));
```

*Важно: padding съшествува и когато записваме обекти във файлове. В този случай, имаме alignment от 8 байта, и след `number` има 4 байта padding, а след `letter` - 7 байта*

---

Ако пуснем същата програма отново, съдържанието на файла ще бъде презаписано. За да добавяме данни към края на файла, използваме флага `std::ios::app`:
```cpp
std::ofstream outFile("file.bin", std::ios::binary | std::ios::app);
```
*Забележка: когато искаме да приложим два флага ги съюзяваме с бинарния оператор `|` (побитово ИЛИ). Това е обяснено по-долу*  

## Четене от файл
За да четем от файл в бинарен режим, трябва да създадем обект от тип `ifstream` и да зададем флага `std::ios::binary`. Това става по следния начин:
```cpp
std::ifstream inFile("file.bin", std::ios::binary);
```

---

За да прочетем данни от бинарен файл, използваме метода `.read()`. Той очаква указател към променлива и броя байтове, които да се прочетат:
```cpp
int number;
inFile.read(reinterpret_cast<char*>(&number), sizeof(number));
std::cout << number << std::endl;
```

Тук:
- `reinterpret_cast<char*>` преобразува указателя към типа `char*`, тъй като `.read()` работи с байтове.
- `sizeof(number)` дава броя байтове, които трябва да се прочетат.

---

Ако знаем, че файлът е съставен само от int-ове, можем да прочетем всичките като използваме цикъл:
```cpp
int number;
while (inFile.read(reinterpret_cast<char*>(&number), sizeof(number)))
{
    std::cout << number << std::endl;
}
```

# Добри практики
## Проверка дали файлът е отворен успешно
Добре е всеки път когато отворим файл, да проверим дали тази операция е била успешна. Например, не можем да отворим файл за писане ако е отворен друг поток към него. Пример от опит - не може да отворим `.csv` файл за писане в С++, който вече е отворен в Excel, т.к. Excel вече има отворен поток към файла.

И в двата типа `ifstream` и `ofstream` методът за проверка е един и същ, а именно методът `.is_open()`:

```cpp
std::ofstream outFile("example.txt");

if (!outFile.is_open())
{
    std::cout << "Error: couldn't open file";
    return -1;
}

outFile << "Hello, world!";
```

```cpp
std::ifstream inFile("example.txt");

if (!inFile.is_open())
{
    std::cout << "Error: couldn't open file";
    return -1;
}

char buffer[256];
inFile >> buffer;
std::cout << buffer;
```

## Затваряне на потока
Добре е когато приключим работа с файла, да затворим ръчно потока. Това не е задължително когато обектът на потока ще бъде унищожен скоро (напр. край на scope-a), но когато програмата ще работи продължително време е редно да освобождаваме файла, когато не го ползваме. Това става с помощта на метода `.close()`

```cpp
std::ifstream inFile("userData.txt");
if (!inFile.is_open())
{
    std::cout << "Error, couldn't open file";
    return -1;
}

char name[32];
int age;

inFile >> name >> age;

inFile.close(); // затваряме потока, т.к. няма да работим повече с файла на този етап

int userInput;
do
{
    // User Interface
} while (userInput != 0);
```



# Малко повече за флаговете при \<fstream>
Когато искаме да работим с по-специфичен режим, или комбинация от режими, забелязахме че има специални флагове. Най-често се използват следните:

- `ios::in` - режим на четене (ifstream)  
- `ios::out` - режим на писане (ofstream), изтрива предишното съдържание  
- `ios::app` - режим на допълване; в комбинация с `ios::out` предотвратява изтриването на предишното съдържание  
- `ios::ate` - режим на допълване*; в комбинация с `ios::out` предотвратява изтриването на предишното съдържание   
- `ios::trunc` - ако файлът съществува, изтрива съдържанието му  
- `ios::binary` - двоичен режим

*когато работим с файлове, имаме указател за четене/писане, като
- при `ios::app` указателят за писане е в края на файла, като **не** може да бъде преместен от там, винаги само ще се добавят данни
- при `ios::ate` указателят за писане е в края на файла, като **може** да бъде преместен; това се използва, когато искаме да пренапишем предишни данни

Припомняме си как работи побитовото ИЛИ `|`:
```
100 | 001 = 101
100 | 011 = 111
001 | 010 = 011
```

Флаговете се възползват точно от това свойство. Всеки флаг представлява някакво число, което в двоичното си представяне има само една 1ца.

Пример:  
| флаг | стойност(десетична) | стойност(двоична) |
|---|---:|---:|
| `ios::binary` | 32 | 00100000 |
| `ios::app` | 8 | 00001000 |

Тоест, когато приложим побитово ИЛИ `|`, крайният флаг ще има вида `00101000`, и така вече с++ знае какви правила да приложи за работа с файла, т.к. всеки бит представлява дали съответния режим на работа е желан или не.

Пълна таблица със стойности:
| флаг | стойност(десетична) | стойност(двоична) |
|---|---:|---:|
| `ios::in` | 1 | 00000001 |
| `ios::out` | 2 | 00000010 |
| `ios::ate` | 4 | 00000100 |
| `ios::app` | 8 | 00001000 |
| `ios::trunc` | 16 | 00010000 |
| `ios::binary` | 32 | 00100000 |